# 카프카 스트림즈 - 시간 윈도우 집계 가이드

## 📊 실무에서 시간 윈도우 집계가 많이 사용되는 이유

### 1. 실시간성
- 배치 작업처럼 하루가 끝나고 집계하는게 아니라 **실시간으로 집계**
- 장애나 이상 징후를 빠르게 감지 가능

### 2. 낮은 레이턴시
- 초 단위로 업데이트되는 대시보드 구현 가능
- 실시간 알람 시스템 구축

### 3. 상태 관리 자동화
- 카프카 스트림즈가 상태를 자동으로 저장/복원
- 애플리케이션 재시작해도 집계 상태 유지

### 4. 확장성
- 파티션 기반 병렬 처리로 대용량 데이터 처리 가능
- 수평 확장 용이

## 🔥 실무 활용 사례

### 1. 전자상거래
```
- 시간별/일별 매출 집계
- 상품별 판매량 추적
- 실시간 재고 모니터링
- 이상 거래 패턴 감지
```

### 2. 광고 플랫폼
```
- 실시간 광고 노출 수 집계
- 클릭률(CTR) 계산
- 시간대별 성과 분석
- 예산 소진 모니터링
```

### 3. 게임 서비스
```
- 동시 접속자 수 집계
- 시간대별 서버 부하 분석
- 게임 내 이벤트 참여율
- 결제 집계
```

### 4. 금융 서비스
```
- 거래량 모니터링
- 이상 거래 탐지
- 시간대별 API 호출 횟수
- 사기 패턴 분석
```

### 5. IoT/센서 데이터
```
- 센서 데이터 집계
- 이상치 탐지
- 트렌드 분석
- 알람 트리거
```

## 📐 시간 윈도우 타입

### 1. Tumbling Window (고정 시간 간격)
```
[00:00 - 01:00] [01:00 - 02:00] [02:00 - 03:00]
     ↓               ↓               ↓
   집계1           집계2           집계3
```
- **특징**: 겹치지 않는 고정 간격
- **사용**: 시간별/일별 집계
- **예시**: 매시간 정각 매출 집계

### 2. Hopping Window (겹치는 시간 간격)
```
[00:00 - 01:00]
      [00:30 - 01:30]
            [01:00 - 02:00]
```
- **특징**: 일정 시간 겹침
- **사용**: 이동 평균 계산
- **예시**: 30분마다 최근 1시간 통계

### 3. Session Window (활동 기반)
```
활동 -------- [gap] ---------- 활동 ------- [gap]
     세션1                        세션2
```
- **특징**: 비활성 시간으로 세션 구분
- **사용**: 사용자 세션 분석
- **예시**: 30분 비활동 시 세션 종료

## 🎯 이 프로젝트의 구현

### 1. 시간별 집계 (1시간 Tumbling Window)
```java
// hourly-sales-topic → 1시간 집계 → hourly-sales-output-topic
TimeWindows.ofSizeWithNoGrace(Duration.ofHours(1))
```
**활용**: 상품별 시간당 매출 집계

### 2. 일별 집계 (1일 Tumbling Window)
```java
// daily-sales-topic → 1일 집계 → daily-sales-output-topic
TimeWindows.ofSizeWithNoGrace(Duration.ofDays(1))
```
**활용**: 카테고리별 일 매출 집계

### 3. 실시간 이벤트 카운팅 (5분 Tumbling Window)
```java
// event-topic → 5분 집계 → event-count-output-topic
TimeWindows.ofSizeWithNoGrace(Duration.ofMinutes(5))
```
**활용**: 이벤트 타입별 발생 빈도 모니터링

## 🚀 테스트 방법

### 1. 시간별 매출 집계 테스트

```bash
# 단건 등록
curl -X POST "http://localhost:8080/api/time-window/hourly-sales?product=노트북&amount=1500000"

# 대량 등록 (추천)
curl -X POST "http://localhost:8080/api/time-window/hourly-sales/bulk"
```

**콘솔 출력 예시:**
```
[스트림-시간별집계] 상품: 노트북, 금액: 1500000, 누적: 0 -> 1500000
[스트림-시간별집계] 상품: 노트북, 금액: 1800000, 누적: 1500000 -> 3300000
[스트림-시간별집계] 상품: 노트북, 금액: 2000000, 누적: 3300000 -> 5300000
✅ [시간별집계 결과] 상품:노트북, 시간대:2025-11-13 14:00~2025-11-13 15:00, 총매출:5300000
```

### 2. 일별 매출 집계 테스트

```bash
# 대량 등록
curl -X POST "http://localhost:8080/api/time-window/daily-sales/bulk"
```

**콘솔 출력 예시:**
```
[스트림-일별집계] 카테고리: 전자제품, 금액: 1500000, 일누적: 0 -> 1500000
[스트림-일별집계] 카테고리: 전자제품, 금액: 800000, 일누적: 1500000 -> 2300000
✅ [일별집계 결과] 날짜:2025-11-13, 카테고리:전자제품, 일매출:4500000
```

### 3. 실시간 이벤트 카운팅 테스트

```bash
# 대량 이벤트 생성
curl -X POST "http://localhost:8080/api/time-window/event/bulk"
```

**콘솔 출력 예시:**
```
[스트림-이벤트카운팅] 입력 - 이벤트타입: USER_LOGIN, 데이터: user-1
[스트림-이벤트카운팅] 입력 - 이벤트타입: PAGE_VIEW, 데이터: /product/1
✅ [5분간 이벤트 카운트] 이벤트:USER_LOGIN, 시간:14:30~14:35, 발생횟수:5
✅ [5분간 이벤트 카운트] 이벤트:PAGE_VIEW, 시간:14:30~14:35, 발생횟수:10
```

## 💡 실무 팁

### 1. 윈도우 크기 선택
- **1분 ~ 5분**: 실시간 모니터링, 알람
- **1시간**: 시간대별 분석
- **1일**: 일일 리포트
- **1주 ~ 1개월**: 트렌드 분석

### 2. Grace Period
```java
// Grace Period를 설정하면 늦게 도착한 데이터도 처리 가능
TimeWindows.ofSizeAndGrace(Duration.ofHours(1), Duration.ofMinutes(5))
```
- 네트워크 지연이나 시계 불일치 대응

### 3. Retention Period
```java
// 상태 저장 시간 설정
Materialized.<String, Long>as("store-name")
    .withRetention(Duration.ofDays(7))
```
- 디스크 용량 관리

### 4. Out-of-Order 처리
- 타임스탬프 기반 처리로 순서 보장
- Late arrival 데이터 처리 정책 필요

## ⚠️ 주의사항

### 1. 시계 동기화
- 모든 서버의 시간이 동기화되어야 함 (NTP 사용 권장)

### 2. 상태 저장소 관리
- RocksDB 디렉토리 크기 모니터링
- 정기적인 백업 필요

### 3. 윈도우 종료 시점
- Tumbling Window는 윈도우가 닫힐 때 결과 출력
- 실시간성이 필요하면 더 짧은 윈도우 사용

### 4. 메모리 관리
- 큰 윈도우는 메모리를 많이 사용
- 적절한 JVM 힙 크기 설정 필요

## 🔄 배치 vs 스트림즈 비교

### 배치 처리 (전통적 방식)
```
00:00 데이터 발생
  ↓
23:59 데이터 수집 완료
  ↓
01:00 배치 작업 실행 (하루치 데이터 집계)
  ↓
02:00 결과 확인 가능
```
- **장점**: 구현 간단, 자원 효율적
- **단점**: 실시간성 없음, 장애 발견 늦음

### 스트림 처리 (카프카 스트림즈)
```
00:00:01 데이터 발생 → 즉시 집계 → 즉시 결과
00:00:02 데이터 발생 → 즉시 집계 → 즉시 결과
00:00:03 데이터 발생 → 즉시 집계 → 즉시 결과
```
- **장점**: 실시간 집계, 빠른 장애 감지
- **단점**: 복잡도 증가, 상태 관리 필요

## 📊 성능 최적화

### 1. 파티셔닝
```java
// 같은 키는 같은 파티션으로
kafkaProducer.sendMessage("topic", "product-123", "10000");
```

### 2. 병렬 처리
```java
// 토픽 생성 시 파티션 수 증가
new NewTopic("hourly-sales-topic", 10, (short) 1);  // 10개 파티션
```

### 3. 캐싱
```java
// 중간 결과 캐싱
.groupByKey()
.windowedBy(...)
.aggregate(...)
.suppress(Suppressed.untilWindowCloses(unbounded()))  // 윈도우 종료 시에만 출력
```

## 🎓 결론

카프카 스트림즈의 시간 윈도우 집계는:

✅ **실무에서 정말 많이 사용됨** (특히 실시간 대시보드, 모니터링)
✅ **일집계, 시간집계 모두 가능**
✅ **배치 처리보다 빠른 인사이트 제공**
✅ **확장성과 안정성이 검증됨**

단, 초기 학습 곡선이 있고 상태 관리가 필요하므로 요구사항에 맞게 선택하는 것이 중요합니다.

